---
title: 继承
date: 2021-10-18 14:49:27
permalink: /pages/49c11e/
categories:
  - 前端
  - JavaScript
tags:
  - 
---

## 私有属性、共有属性、静态属性
- 私有属性和方法：只能在构造函数内访问，不能被外部访问（使用 `var`、`let` 等声明）
- 共有属性和方法（实例方法）：对象外可以访问到对象内的属性和方法（通过 this 或 prototype设置）
- 静态属性和方法：定于在构造函数上的属性或方法，如 `Person.name` , 不需要实例化就可以调用

## 遍历实例属性的方法
- `for...in...`：能获取到实例对象自身属性和原型链上的属性（可通过 `.hasOwnProperty()` 来判断是否属于实例本身 ）
- `Object.keys()`：只能获取实例对象自身的属性（可枚举的）
- `Object.getOwnPropertyNames()`：只能获取实例对象自身的属性（包括不可枚举）


## 1. 原型链继承
将父类实例作为子类的 `prototype`, 通过原型链继承多个引用类型的属性和方法。

关键代码： `Child.prototype = new Parent()`

实现：

```javascript
  function Parent () {
    this.name = 'parent'
  }
  Parent.prototype.getName = function () {
    return this.name
  }

  function Child () {
    this.age = 6
  }

  Child.prototype = new Parent()

  const c1 = new Child()
  console.log(c1.getName())
```

缺点：
1. 原型中包含的引用值会在所有实例间共享
2. 子类在实例化时不能给父类构造函数传参
3. 无法实现多继承（因为已经指定了原型对象）

## 盗用构造函数继承
在子类构造函数内部使用 `call` 或 `apply` 来调用父类构造函数。

关键代码： `Parent.call(this)`

实现：

```javascript
  function Parent (name, age) {
    this.name = name
    this.age = age
    this.colors = ['white', 'black']
  }

  function Child (name, age) {
    Parent.call(this, name, age)
  }

  const c1 = new Child('雪莱', 18)
  console.log(c1) // { name: "雪莱", age: 18, colors: ['white', 'black', 'pink'] }

  c1.colors.push('pink')

  const c2 = new Child()

  console.log(c1.colors) // ['white', 'black', 'pink']
  console.log(c2.colors) // ['white', 'black']
```

优点：
1. 解决了子类实例共享父类引用值的问题，如上例中 `colors`
2. 可以向父类构造函数传递参数
3. 实现多继承

缺点：
1. 不能使用父类原型上的方法


## 参考
《JavaScript高级程序设计》

[https://juejin.cn/post/6844904098941108232](https://juejin.cn/post/6844904098941108232)
